<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Support Vector Machines (SVM) in Text Classification</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }
  </style>
</head>
<body>
<h1 id="topic-support-vector-machines-svm-in-text-classification">Topic: Support Vector Machines (SVM) in Text Classification</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>Support Vector Machines (SVMs) are supervised machine learning models that can be used for both classification and regression tasks. In text classification, the goal is to assign a predefined category (or label) to a given text document. SVMs achieve this by finding an optimal hyperplane that separates data points belonging to different categories in a high-dimensional space, where each dimension corresponds to a feature extracted from the text (e.g., word frequencies, TF-IDF scores).</p>
<p>More formally:</p>
<ul>
<li><strong>Goal:</strong> To find the hyperplane that maximizes the margin between different classes. The margin is the distance between the hyperplane and the closest data points from each class (called support vectors).</li>
<li><strong>Features:</strong> Text documents are converted into numerical feature vectors. Common techniques include:<ul>
<li><strong>Bag-of-Words (BoW):</strong> Counts the frequency of each word in the document.</li>
<li><strong>Term Frequency-Inverse Document Frequency (TF-IDF):</strong> Weights words based on their frequency within a document and rarity across the entire corpus.</li>
<li><strong>Word Embeddings (e.g., Word2Vec, GloVe):</strong> Maps words to dense vector representations capturing semantic relationships.</li>
</ul>
</li>
<li><strong>Kernel Trick:</strong> SVMs can use kernel functions (e.g., linear, polynomial, radial basis function (RBF)) to implicitly map the input data into a higher-dimensional space where linear separation is possible, even if the data is not linearly separable in the original space.  This avoids explicitly computing transformations of the feature space, making the process computationally efficient. The kernel function computes the dot product of the data points in this higher-dimensional space.</li>
<li><strong>Classification:</strong> Given a new text document (converted into a feature vector), the SVM classifies it by determining which side of the optimal hyperplane the feature vector falls on.</li>
</ul>
<p>We use SVMs in text classification by first training the model on a labeled dataset of text documents. During training, the SVM learns the optimal hyperplane parameters.  Then, we can use the trained model to predict the category of new, unseen text documents.</p>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>A good application scenario is <strong>Spam Email Detection</strong>.  We can train an SVM classifier to distinguish between spam and non-spam emails (also called "ham").</p>
<ul>
<li><strong>Input Data:</strong> A dataset of emails labeled as either "spam" or "ham."</li>
<li><strong>Feature Extraction:</strong> Use TF-IDF to convert the email text into numerical feature vectors.  Words common in spam emails (e.g., "discount," "urgent," "free") will likely have high TF-IDF scores in spam emails and low scores in ham emails.</li>
<li><strong>Training:</strong> Train an SVM classifier (e.g., with a linear or RBF kernel) on the labeled dataset. The SVM learns the optimal hyperplane that separates spam emails from ham emails based on their TF-IDF feature vectors.</li>
<li><strong>Prediction:</strong>  When a new email arrives, convert its text into a TF-IDF feature vector and feed it to the trained SVM model. The SVM will predict whether the email is spam or ham based on which side of the hyperplane the email's feature vector falls on.</li>
<li><strong>Benefit:</strong>  SVMs can effectively capture the subtle differences in word usage and patterns that distinguish spam from legitimate emails, even when spammers try to obfuscate their messages.</li>
</ul>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>Here's how you can use scikit-learn to train an SVM classifier for text classification:</p>
<pre class="codehilite"><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report

# Sample data (replace with your actual text data)
data = datasets.load_files('text_data',encoding='utf-8', decode_error='ignore') #Example is data stored in a directory called text_data, with subdirs labelled the category
X, y = data.data, data.target

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Feature extraction using TF-IDF
vectorizer = TfidfVectorizer(stop_words='english', max_df=0.7) #remove words present in &gt; 70% documents.  Remove English stopwords
X_train_tfidf = vectorizer.fit_transform(X_train)
X_test_tfidf = vectorizer.transform(X_test)

# Train an SVM classifier (Linear Kernel)
svm_classifier = SVC(kernel='linear', C=1.0)  # You can experiment with different kernels and C values
svm_classifier.fit(X_train_tfidf, y_train)

# Make predictions on the test set
y_pred = svm_classifier.predict(X_test_tfidf)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f&quot;Accuracy: {accuracy:.4f}&quot;)
print(classification_report(y_test, y_pred))
</code></pre>

<p><strong>Explanation:</strong></p>
<ol>
<li><strong>Data Loading and Splitting:</strong>  Loads the text data and splits it into training and testing sets. Replace <code>'text_data'</code> with the directory containing subdirectories each labelled a category, and containing the text files for that category.</li>
<li><strong>TF-IDF Vectorization:</strong> <code>TfidfVectorizer</code> converts the text data into TF-IDF feature vectors. <code>stop_words='english'</code> removes common English stop words (e.g., "the," "a," "is"). <code>max_df=0.7</code> ignores terms that have a document frequency strictly higher than 70% of the documents. This helps to focus on more informative words. The <code>fit_transform</code> method is used on the training data to learn the vocabulary and IDF weights, and then <code>transform</code> is used on the testing data to convert it into the same feature space.</li>
<li><strong>SVM Training:</strong> <code>SVC</code> is the SVM classifier implementation in scikit-learn.  <code>kernel='linear'</code> specifies a linear kernel. <code>C</code> is the regularization parameter, which controls the trade-off between maximizing the margin and minimizing the training error.  A smaller <code>C</code> allows for more misclassifications in the training data to achieve a larger margin, which can improve generalization performance. The <code>fit</code> method trains the classifier on the training data.</li>
<li><strong>Prediction and Evaluation:</strong> The <code>predict</code> method makes predictions on the test set.  The code then calculates and prints the accuracy and classification report to assess the model's performance.  The classification report provides precision, recall, F1-score, and support for each class.</li>
</ol>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How does the choice of the kernel function (e.g., linear, RBF, polynomial) affect the performance of an SVM in text classification, and how can you choose the best kernel for a specific task?  What are the computational trade-offs of using different kernel functions?</p>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Topic Modeling: Latent Semantic Analysis (LSA)</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }
  </style>
</head>
<body>
<h1 id="topic-topic-modeling-latent-semantic-analysis-lsa">Topic: Topic Modeling: Latent Semantic Analysis (LSA)</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>Latent Semantic Analysis (LSA), also known as Latent Semantic Indexing (LSI), is an unsupervised natural language processing technique used to discover underlying topics in a collection of documents. It aims to find the hidden (latent) semantic relationships between words and documents based on their co-occurrence patterns.  Essentially, it's a way to reduce the dimensionality of the term-document matrix while preserving important semantic relationships.</p>
<p><strong>What it is:</strong></p>
<ul>
<li>LSA starts with a term-document matrix, where each row represents a term (word) and each column represents a document. The value in each cell (i,j) represents the frequency (or a weighted version like TF-IDF) of term 'i' in document 'j'.</li>
<li>Then, it applies Singular Value Decomposition (SVD) to decompose this matrix into three matrices: U, Σ, and V<sup>T</sup>.  The SVD decomposes the original term-document matrix into three matrices, approximating it.</li>
<li><strong>U (Term-Topic Matrix):</strong> Represents the relationship between terms and topics. Each row corresponds to a term, and each column corresponds to a topic. The values indicate the importance of each term to each topic.</li>
<li><strong>Σ (Singular Values Matrix):</strong> A diagonal matrix containing singular values. These values represent the strength or importance of each topic. We typically select the top <em>k</em> singular values (and corresponding rows and columns from U and V<sup>T</sup>) to reduce dimensionality and retain the most important topics.</li>
<li><strong>V<sup>T</sup> (Topic-Document Matrix):</strong> Represents the relationship between topics and documents. Each row corresponds to a topic, and each column corresponds to a document. The values indicate the importance of each topic to each document.</li>
</ul>
<p><strong>How we can use it:</strong></p>
<ul>
<li><strong>Topic discovery:</strong> LSA helps identify the main topics present in a corpus of documents, even if those topics are not explicitly named.</li>
<li><strong>Document retrieval:</strong> By representing documents and queries in the same latent semantic space, LSA allows for semantic matching, improving the accuracy of information retrieval systems. Documents that are semantically similar but do not share many words can be identified as relevant.</li>
<li><strong>Document similarity:</strong> By comparing the vectors in the topic-document space (V<sup>T</sup>), we can measure the similarity between documents.</li>
<li><strong>Dimensionality reduction:</strong> LSA reduces the dimensionality of the term-document matrix, making it more efficient to store and process text data.</li>
<li><strong>Text Summarization:</strong> LSA can identify the most important sentences/passages related to identified topics, forming the basis for text summarization.</li>
</ul>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>Imagine you have a large collection of news articles from different sources covering various topics. You want to automatically group these articles into different categories (e.g., "Politics," "Sports," "Technology," "Business") without manually reading and labeling each article.</p>
<p>LSA can be used to:</p>
<ol>
<li><strong>Build a term-document matrix:</strong> Represent each article as a document, and each unique word as a term. The matrix entries contain TF-IDF scores for each word in each document.</li>
<li><strong>Apply SVD:</strong> Decompose the term-document matrix using SVD and reduce the dimensionality by selecting the top <em>k</em> singular values (and corresponding vectors).</li>
<li><strong>Identify topics:</strong> Analyze the term-topic matrix (U) to identify the most important words associated with each of the <em>k</em> topics. For example, topic 1 might have words like "election," "candidate," "vote," suggesting it's related to "Politics."</li>
<li><strong>Assign articles to topics:</strong> Analyze the topic-document matrix (V<sup>T</sup>) to determine the strength of each topic in each article.  Assign each article to the topic with the highest score.</li>
<li><strong>Recommend related articles:</strong> Once articles are grouped by topics, you can easily recommend similar articles to users based on their reading history or interests.</li>
</ol>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<pre class="codehilite"><code class="language-python">import numpy as np
from sklearn.decomposition import TruncatedSVD
from sklearn.feature_extraction.text import TfidfVectorizer

# Sample documents
documents = [
    &quot;The cat sat on the mat.&quot;,
    &quot;The dog barked at the cat.&quot;,
    &quot;Dogs are loyal pets.&quot;,
    &quot;Cats are independent animals.&quot;,
    &quot;Space exploration is fascinating.&quot;,
    &quot;The moon is a satellite of Earth.&quot;,
    &quot;Rockets are used for space travel.&quot;
]

# 1. Create TF-IDF matrix
vectorizer = TfidfVectorizer(stop_words='english') # Remove common English words
X = vectorizer.fit_transform(documents)

# 2. Apply Truncated SVD (LSA)
n_components = 3  # Number of topics to extract
lsa = TruncatedSVD(n_components=n_components, algorithm = 'arpack') # Using arpack for sparse data.

lsa.fit(X)
topic_vectors = lsa.transform(X)  # Documents represented in the topic space

# 3. Print topics and their top words
terms = vectorizer.get_feature_names_out()
for i, comp in enumerate(lsa.components_):
    terms_with_score = zip(terms, comp)
    sorted_terms = sorted(terms_with_score, key=lambda x: x[1], reverse=True)[:10]  # Top 10 words
    print(f&quot;Topic {i+1}:&quot;)
    for term, score in sorted_terms:
        print(f&quot;\t{term}: {score:.3f}&quot;)

# 4. Document representation in topic space:
# topic_vectors[i] now represents the i-th document in the lower-dimensional topic space.
# You can then use these vectors for document similarity or clustering.

print(&quot;\nDocument representation in topic space:&quot;)
for i, doc_vector in enumerate(topic_vectors):
    print(f&quot;Document {i+1}: {doc_vector}&quot;)
</code></pre>

<p><strong>Explanation:</strong></p>
<ol>
<li><strong>TF-IDF Vectorization:</strong> We use <code>TfidfVectorizer</code> from scikit-learn to create the term-document matrix and apply TF-IDF weighting, which normalizes the word frequencies.  Stop words are removed to focus on more meaningful terms.</li>
<li><strong>TruncatedSVD:</strong>  <code>TruncatedSVD</code> is used for dimensionality reduction. It's computationally more efficient than full SVD when dealing with large sparse matrices, which is common in text data.  We set <code>n_components</code> to specify the number of topics to extract. We also specified <code>algorithm='arpack'</code> which is usually better for sparse data.</li>
<li><strong>Topic Interpretation:</strong>  We iterate through the components (topics) of the LSA model and print the top words associated with each topic based on their scores in the <code>lsa.components_</code> matrix. This helps us interpret the meaning of each topic.  <code>terms</code> variable contains the vocabulary.</li>
<li><strong>Document representation:</strong> After <code>lsa.transform(X)</code> we obtained document vectors. These vectors represent how each document is related to each of the topic vectors.</li>
</ol>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How does LSA handle polysemy (words with multiple meanings) and synonymy (multiple words with the same meaning), and what are the limitations of LSA in addressing these challenges? How can other topic modeling techniques, like LDA, overcome some of these limitations?</p>
</body>
</html>
